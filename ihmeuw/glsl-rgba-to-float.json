{"readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/ihmeuw/glsl-rgba-to-float\">glsl-rgba-to-float</a><div class=\"contrib\"></div></h1>\n<h2 id=\"installation\">Installation</h2>\n<pre><code class=\"lang-bash\"><div class=\"line\"><span class=\"source shell\"><span>npm&#xA0;install&#xA0;--save&#xA0;glsl-rgba-to-float</span></span></div>\n</code></pre>\n<h2 id=\"signature\">Signature</h2>\n<pre><code class=\"lang-glsl\"><div class=\"line\"><span class=\"source glsl\"><span class=\"storage type glsl\"><span>float</span></span><span class=\"meta function c\"><span class=\"punctuation whitespace function leading c\"><span>&#xA0;</span></span><span class=\"entity name function c\"><span>rgbaToFloat</span></span><span class=\"meta parens c\"><span class=\"punctuation section parens begin c\"><span>(</span></span><span class=\"storage type glsl\"><span>vec4</span></span><span>&#xA0;texelRGBA,&#xA0;</span><span class=\"storage type glsl\"><span>bool</span></span><span>&#xA0;littleEndian</span><span class=\"punctuation section parens end c\"><span>)</span></span></span><span>;</span></span></span></div>\n</code></pre>\n<h2 id=\"usage\">Usage</h2>\n<p>This package exports a GLSL function, <code>rgbaToFloat</code>, that decodes 32-bit floating point values from the RGBA channels of a WebGL texture. This is a workaround for the lack of support in baseline WebGL 1.0 for floating-point textures. WebGL 2.0 allows floating-point textures, and WebGL 1.0 allows them when the extension <code>OES_texture_float</code> is available, but some users may be using a browser or hardware that don&apos;t have these capabilities. This package seeks to fill that gap.</p>\n<p>In baseline WebGL 1.0, a maximum of 32 bits are allotted for each texel (pixel in a texture). It&apos;s therefore possible to create textures in which each texel represents a single 32-bit float. A straightforward way to do that is to create a <code>Float32Array</code> with the desired texel values, then reinterpret the underlying binary data of the typed array&apos;s <code>ArrayBuffer</code> as a <code>Uint8Array</code>. This latter array can then be passed to the WebGL system as an RGBA texture of type <code>UNSIGNED_BYTE</code>. This &quot;tricks&quot; WebGL into treating a single 32-bit float as a vector of four bytes.</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>//&#xA0;JavaScript&#xA0;control&#xA0;code</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>//&#xA0;construct&#xA0;the&#xA0;pixel&#xA0;data</span></span></div><div class=\"line\"><span class=\"source js\"><span>const&#xA0;floatArray&#xA0;=&#xA0;new&#xA0;Float32Array([&#xA0;/*&#xA0;pixels&#xA0;*/&#xA0;]);</span></span></div><div class=\"line\"><span class=\"source js\"><span>const&#xA0;uintArray&#xA0;=&#xA0;new&#xA0;Uint8Array(floatArray.buffer);</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>//&#xA0;bind&#xA0;the&#xA0;pixel&#xA0;data&#xA0;to&#xA0;a&#xA0;WebGL&#xA0;texture</span></span></div><div class=\"line\"><span class=\"source js\"><span>gl.texImage2D(</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;gl.TEXTURE_2D,&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;target</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;0,&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;mipmap&#xA0;level</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;gl.RGBA,&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;internal&#xA0;format:&#xA0;4&#xA0;color&#xA0;channels</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;width,&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;width&#xA0;of&#xA0;texture&#xA0;in&#xA0;pixels</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;height,&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;height&#xA0;of&#xA0;texture&#xA0;in&#xA0;pixels</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;0,&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;border:&#xA0;must&#xA0;be&#xA0;0</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;gl.RGBA,&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;format:&#xA0;must&#xA0;be&#xA0;the&#xA0;same&#xA0;as&#xA0;internal&#xA0;format</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;gl.UNSIGNED_BYTE,&#xA0;//&#xA0;type:&#xA0;8&#xA0;bits&#xA0;per&#xA0;channel</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;uintArray,&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;pixels</span></span></div><div class=\"line\"><span class=\"source js\"><span>);</span></span></div>\n</code></pre>\n<p><code>rgbaToFloat</code> is designed to be consumed as a <a href=\"https://github.com/glslify/glslify\">GLSLify</a> module (though other methods may be used to copy the source code into your shader). To decode a texel in your shader code, pass the <code>vec4</code> representing the texel to the function <code>rgbaToFloat</code>. Note that because the function has to decode the float from its constituent bits, it needs to know whether the machine on which it&apos;s running uses <a href=\"https://en.wikipedia.org/wiki/Endianness\">big-endian or little-endian representation</a>.</p>\n<pre><code class=\"lang-glsl\"><div class=\"line\"><span class=\"source glsl\"><span class=\"comment line double-slash c++\"><span class=\"punctuation definition comment c++\"><span>//</span></span><span>&#xA0;fragment&#xA0;shader</span><span>&#xA0;</span></span></span></div><div class=\"line\"><span class=\"source glsl\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source glsl\"><span>#</span><span class=\"meta preprocessor keyword import define glsl\"><span>pragma&#xA0;glslify:</span></span><span class=\"entity name function glsl\"><span>&#xA0;rgbaToFloat&#xA0;</span></span><span class=\"operator glsl\"><span>=&#xA0;</span></span><span class=\"keyword operator glsl\"><span>require</span></span><span>(</span><span class=\"string quoted double\"><span>&apos;glsl-rgba-to-float&apos;</span></span><span>)</span><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source glsl\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"comment line double-slash c++\"><span class=\"punctuation definition comment c++\"><span>//</span></span><span>&#xA0;does&#xA0;the&#xA0;machine&#xA0;use&#xA0;little-endian&#xA0;representation?</span><span>&#xA0;</span></span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"storage modifier glsl\"><span>uniform</span></span><span>&#xA0;</span><span class=\"storage type glsl\"><span>bool</span></span><span>&#xA0;littleEndian;</span></span></div><div class=\"line\"><span class=\"source glsl\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"comment line double-slash c++\"><span class=\"punctuation definition comment c++\"><span>//</span></span><span>&#xA0;the&#xA0;texture</span><span>&#xA0;</span></span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"storage modifier glsl\"><span>uniform</span></span><span>&#xA0;</span><span class=\"storage type glsl\"><span>sampler2D</span></span><span>&#xA0;texture;</span></span></div><div class=\"line\"><span class=\"source glsl\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"comment line double-slash c++\"><span class=\"punctuation definition comment c++\"><span>//</span></span><span>&#xA0;texture&#xA0;coordinates,&#xA0;passed&#xA0;from&#xA0;the&#xA0;vertex&#xA0;shader</span><span>&#xA0;</span></span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"storage modifier glsl\"><span>varying</span></span><span>&#xA0;</span><span class=\"storage type glsl\"><span>vec2</span></span><span>&#xA0;textureCoords;</span></span></div><div class=\"line\"><span class=\"source glsl\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"storage type glsl\"><span>void</span></span><span class=\"meta function c\"><span class=\"punctuation whitespace function leading c\"><span>&#xA0;</span></span><span class=\"entity name function c\"><span>main</span></span><span class=\"meta parens c\"><span class=\"punctuation section parens begin c\"><span>(</span></span><span class=\"punctuation section parens end c\"><span>)</span></span></span><span>&#xA0;</span><span class=\"meta block c\"><span class=\"punctuation section block begin c\"><span>{</span></span></span></span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"meta function c\"><span class=\"meta block c\"><span>&#xA0;&#xA0;</span><span class=\"storage type glsl\"><span>vec4</span></span><span>&#xA0;texelRGBA&#xA0;=</span><span class=\"meta function-call c\"><span class=\"punctuation whitespace function-call leading c\"><span>&#xA0;</span></span><span class=\"support function any-method c\"><span>texture2D</span></span><span>(</span></span><span>texture,&#xA0;textureCoords);</span></span></span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"meta function c\"><span class=\"meta block c\"><span>&#xA0;&#xA0;</span><span class=\"storage type glsl\"><span>float</span></span><span>&#xA0;texelFloat&#xA0;=</span><span class=\"meta function-call c\"><span class=\"punctuation whitespace function-call leading c\"><span>&#xA0;</span></span><span class=\"support function any-method c\"><span>rgbaToFloat</span></span><span>(</span></span><span>texelRGBA,&#xA0;littleEndian);</span></span></span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"meta function c\"><span class=\"meta block c\"><span class=\"punctuation whitespace comment leading c++\"><span>&#xA0;&#xA0;</span></span><span class=\"comment line double-slash c++\"><span class=\"punctuation definition comment c++\"><span>//</span></span><span>&#xA0;use&#xA0;the&#xA0;decoded&#xA0;float&#xA0;for&#xA0;something&#xA0;wonderful...</span><span>&#xA0;</span></span></span></span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"meta function c\"><span class=\"meta block c\"><span class=\"punctuation section block end c\"><span>}</span></span></span></span></span></div>\n</code></pre>\n<p>Here&apos;s a simple way to compute endianness in JavaScript. Pass the result as a <code>uniform</code> variable to your shader.</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>const&#xA0;littleEndian&#xA0;=&#xA0;(function&#xA0;machineIsLittleEndian()&#xA0;{</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;const&#xA0;uint8Array&#xA0;=&#xA0;new&#xA0;Uint8Array([0xAA,&#xA0;0xBB]);</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;const&#xA0;uint16array&#xA0;=&#xA0;new&#xA0;Uint16Array(uint8Array.buffer);</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;return&#xA0;uint16array[0]&#xA0;===&#xA0;0xBBAA;</span></span></div><div class=\"line\"><span class=\"source js\"><span>})();</span></span></div>\n</code></pre>\n"}