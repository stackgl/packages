{"readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/rreusser/glsl-solid-wireframe\">glsl-solid-wireframe</a><div class=\"contrib\"></div></h1>\n<blockquote>\n<p>draw wireframes on a triangular mesh using a fragment shader</p>\n</blockquote>\n<p>This module uses barycentric coordinates to draw a wireframe on a solid triangular mesh. Alternatively, it will simply draw grid lines at integer component values of a float- or vector-valued variable which you give it.</p>\n<p>You can see a detailed explanation of the technique <a href=\"http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/\">here</a>. It uses <a href=\"https://www.khronos.org/registry/gles/extensions/OES/OES_standard_derivatives.txt\"><code>OES_standard_derivatives</code></a> to scale the lines to a uniform width, but also exposes a basic fallback that scales lines relative to the size of the triangle in case <code>OES_standard_derivatives</code> is not available. (The fallback is pretty bad.) <a href=\"http://webglstats.com/webgl/extension/OES_standard_derivatives\">Support for <code>OES_standard_derivatives</code> is 96% for mobile and 99% across the board</a>.</p>\n<p>Please <strong><em>do not</em></strong> confuse it with nVidia&apos;s <a href=\"http://developer.download.nvidia.com/SDK/10/direct3d/Source/SolidWireframe/Doc/SolidWireframe.pdf\">Solid Wireframe technique</a>. That technique uses a geometry shader so will not be available in WebGL any time soon. The convenience function used here to generate barycentric coordinates produces a similar result but duplicates and expands the geometry to achieve it. It&apos;s real wasteful. Not perfect.</p>\n<h2 id=\"example\">Example</h2>\n<p align=\"center\">\n  <a href=\"http://rreusser.github.io/glsl-solid-wireframe/barycentric.html\">\n    <img src=\"https://raw.githubusercontent.com/rreusser/glsl-solid-wireframe/master/docs/images/barycentric.png\" width=\"200\">\n  </a>\n  <br>\n  Barycentric coordinate based mesh. <a href=\"http://rreusser.github.io/glsl-solid-wireframe/barycentric.html\">See demo &#x2192;</a>\n</p>\n\n<p align=\"center\">\n  <a href=\"http://rreusser.github.io/glsl-solid-wireframe/cartesian.html\">\n    <img src=\"https://raw.githubusercontent.com/rreusser/glsl-solid-wireframe/master/docs/images/cartesian.png\" width=\"200\">\n  </a>\n  <br>\n  Cartesian coordinate based mesh using <code>5 * position.xy</code> as the input. <a href=\"http://rreusser.github.io/glsl-solid-wireframe/cartesian.html\">See demo &#x2192;</a>\n</p>\n\n<p>Or see an interactive demo <a href=\"http://rreusser.github.io/glsl-solid-wireframe/demo.html\">here</a>. Code using <a href=\"https://github.com/regl-project/regl\">regl</a> to draw a barycentric triangular mesh is below.</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>const&#xA0;regl&#xA0;=&#xA0;require(&apos;regl&apos;)({extensions:&#xA0;[&apos;oes_standard_derivatives&apos;]});</span></span></div><div class=\"line\"><span class=\"source js\"><span>const&#xA0;glsl&#xA0;=&#xA0;require(&apos;glslify&apos;);</span></span></div><div class=\"line\"><span class=\"source js\"><span>const&#xA0;camera&#xA0;=&#xA0;require(&apos;regl-camera&apos;)(regl);</span></span></div><div class=\"line\"><span class=\"source js\"><span>const&#xA0;mesh&#xA0;=&#xA0;require(&apos;glsl-solid-wireframe&apos;)(require(&apos;bunny&apos;));</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>const&#xA0;draw&#xA0;=&#xA0;regl({</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;frag:&#xA0;glsl`</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;#extension&#xA0;GL_OES_standard_derivatives&#xA0;:&#xA0;enable</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;precision&#xA0;mediump&#xA0;float;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;#pragma&#xA0;glslify:&#xA0;grid&#xA0;=&#xA0;require(glsl-solid-wireframe/barycentric/scaled)</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;varying&#xA0;vec2&#xA0;b;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;void&#xA0;main&#xA0;()&#xA0;{</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;gl_FragColor&#xA0;=&#xA0;vec4(vec3(grid(b,&#xA0;1.0)),&#xA0;1);</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;}</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;`,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;vert:&#xA0;`</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;precision&#xA0;mediump&#xA0;float;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;uniform&#xA0;mat4&#xA0;projection,&#xA0;view;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;attribute&#xA0;vec3&#xA0;position;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;attribute&#xA0;vec2&#xA0;barycentric;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;varying&#xA0;vec2&#xA0;b;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;void&#xA0;main&#xA0;()&#xA0;{</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;b&#xA0;=&#xA0;barycentric;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;gl_Position&#xA0;=&#xA0;projection&#xA0;*&#xA0;view&#xA0;*&#xA0;vec4(position,&#xA0;1);</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;}</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;`,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;attributes:&#xA0;{</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;position:&#xA0;mesh.positions,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;barycentric:&#xA0;mesh.barycentric</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;},</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;elements:&#xA0;mesh.cells,</span></span></div><div class=\"line\"><span class=\"source js\"><span>});</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>regl.frame(()&#xA0;=&gt;&#xA0;{</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;regl.clear({color:&#xA0;[1,&#xA0;1,&#xA0;1,&#xA0;1],&#xA0;depth:&#xA0;1});</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;camera(draw);</span></span></div><div class=\"line\"><span class=\"source js\"><span>});</span></span></div>\n</code></pre>\n<h2 id=\"api\">API</h2>\n<h3 id=\"installation\">Installation</h3>\n<pre><code class=\"lang-bash\"><div class=\"line\"><span class=\"source shell\"><span>$&#xA0;npm&#xA0;install&#xA0;glsl-solid-wireframe</span></span></div>\n</code></pre>\n<h3 id=\"javascript-api\">JavaScript API</h3>\n<p>In order to use the barycentric wireframe shader, each triangle must have a <code>vec2</code> vertex attribute that is <code>[0, 0]</code> in one corner, <code>[1, 0]</code> in the second, and <code>[0, 1]</code> in the third. Since assigning these attributes without duplicating the mesh is not a straightforward assignment problem, the module exports a function that simply expands the mesh and assigns the proper attributes. The extra storage may be prohibitive, but you certainly don&apos;t need to use this convenience function in order to use the shaders. You may be able to do better (PR welcome!) or barycentric coordinate assignment may simply be trivial for your geometry.</p>\n<h3 id=\"var-wmesh-require-glsl-solid-wireframe-mesh-opts-\">var wmesh = require(&apos;glsl-solid-wireframe&apos;)(mesh[, opts = {}])</h3>\n<p>Create a wireframe mesh given an existing triangular mesh.</p>\n<p>The input must be a simplicial complex consisting of <code>positions</code> and <code>cells</code>.</p>\n<p>The wireframe mesh has these properties:</p>\n<ul>\n<li><code>wmesh.positions</code>: an array of <code>[x, y, z]</code> vertex arrays</li>\n<li><code>wmesh.cells</code>: an array of triangle indices</li>\n<li><code>wmesh.attributes</code>: extra attributes transferred from the input. See below.</li>\n</ul>\n<p>You may optionally provide <code>opts.attributes</code>. If you do, the attribute references will be copied for each element into a new list of vertex attribute arrays.</p>\n<h3 id=\"glslify-api\">glslify API</h3>\n<p>To require the modules via <a href=\"https://github.com/stackgl/glslify\">glslify</a>:</p>\n<pre><code class=\"lang-glsl\"><div class=\"line\"><span class=\"source glsl\"><span class=\"meta preprocessor c\"><span>#</span><span class=\"keyword control import c\"><span>pragma</span></span><span>&#xA0;glslify&#xA0;bary_wire_scaled&#xA0;=&#xA0;require(glsl-solid-wireframe/barycentric/scaled)</span></span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"meta preprocessor c\"><span>#</span><span class=\"keyword control import c\"><span>pragma</span></span><span>&#xA0;glslify&#xA0;bary_wire_unscaled&#xA0;=&#xA0;require(glsl-solid-wireframe/barycentric/unscaled)</span></span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"meta preprocessor c\"><span>#</span><span class=\"keyword control import c\"><span>pragma</span></span><span>&#xA0;glslify&#xA0;cart_wire_scaled&#xA0;=&#xA0;require(glsl-solid-wireframe/cartesian/scaled)</span></span></span></div><div class=\"line\"><span class=\"source glsl\"><span class=\"meta preprocessor c\"><span>#</span><span class=\"keyword control import c\"><span>pragma</span></span><span>&#xA0;glslify&#xA0;cart_wire_unscaled&#xA0;=&#xA0;require(glsl-solid-wireframe/cartesian/unscaled)</span></span></span></div>\n</code></pre>\n<h4 id=\"float-bary_wire_scaled-vec2-b-float-width-float-feather-0-5-\"><code>float bary_wire_scaled(vec2 b, float width[, float feather = 0.5])</code></h4>\n<p>Returns 0.0 on the grid lines and 1.0 on the rest of the triangle. <code>b</code> is the <code>varying vec2</code> barycentric coordinate, <code>width</code> is the width of the grid lines in pixels, and <code>feather</code> is the radius on either side of <code>width</code> over which to transition in order to avoid sharp aliasing. <code>feather</code> must be strictly greater than zero to avoid inequality fighting issues with <code>smoothstep</code>. In order to use this shader, <code>OES_standard_derivatives</code> must be available so this function is only available in a fragment shader.</p>\n<h4 id=\"float-bary_wire_unscaled-vec2-b-float-width-float-feather-0-5-\"><code>float bary_wire_unscaled(vec2 b, float width[, float feather = 0.5])</code></h4>\n<p>Returns 0.0 on the grid lines and 1.0 on the rest of the triangle. <code>b</code> is the <code>varying vec2</code> barycentric coordinate, <code>width</code> is the width of the grid lines where <code>0.0</code> shows no lines at all and <code>1.0</code> causes all three lines to meet in the center, and <code>feather</code> is the radius on either side of <code>width</code> over which to transition in order to avoid sharp aliasing. <code>feather</code> must be strictly greater than zero to avoid inequality fighting issues with <code>smoothstep</code>. This shader does not use <code>OES_standard_derivatives</code>.</p>\n<h4 id=\"float-cart_wire_scaled-gentype-f-float-width-float-feather-0-5-\"><code>float cart_wire_scaled(genType f, float width[, float feather = 0.5])</code></h4>\n<p>Returns 0.0 on the grid lines and 1.0 on the rest of the triangle. <code>f</code> is a <code>float</code>, <code>vec2</code>, <code>vec3</code>, or <code>vec4</code>. Grid lines will appear at integer values of any of the components. <code>width</code> is the width of the grid lines in pixels, and <code>feather</code> is the radius on either side of <code>width</code> over which to transition in order to avoid sharp aliasing. <code>feather</code> must be strictly greater than zero to avoid inequality fighting issues with <code>smoothstep</code>. In order to use this shader, <code>OES_standard_derivatives</code> must be available so that this is only available in a fragment shader.</p>\n<h4 id=\"float-cart_wire_unscaled-gentype-f-float-width-float-feather-0-5-\"><code>float cart_wire_unscaled(genType f, float width[, float feather = 0.5])</code></h4>\n<p>Returns 0.0 on the grid lines and 1.0 on the rest of the triangle. <code>f</code> is a <code>float</code>, <code>vec2</code>, <code>vec3</code>, or <code>vec4</code>. Grid lines will appear at integer values of any of components. <code>width</code> is the width of the grid lines where <code>0.0</code> shows no lines at all and <code>1.0</code> causes all three lines to meet in the center, and <code>feather</code> is the radius on either side of <code>width</code> over which to transition in order to avoid sharp aliasing. <code>feather</code> must be strictly greater than zero to avoid inequality fighting issues with <code>smoothstep</code>. This shader does not use <code>OES_standard_derivatives</code>.</p>\n<h2 id=\"see-also\">See also</h2>\n<ul>\n<li><a href=\"https://github.com/substack/screen-projected-lines\">screen-projected-lines</a></li>\n</ul>\n<h2 id=\"license\">License</h2>\n<p>&#xA9; Ricky Reusser 2016. MIT License.</p>\n"}