{"readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/realazthat/glsl-sat\">glsl-sat</a><div class=\"contrib\"></div></h1>\n<p>####Description</p>\n<p>glsl-sat is a shader generator for WebGL, to generate a summed-area-table texture of an input texture.</p>\n<p>Based on <a href=\"http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2012/10/GDC2005_SATEnvironmentReflections.pdf\"><strong>Summed-Area Tables Area Tables</strong> And Their Application to Dynamic And Their Application to\nDynamic Glossy Environment Reflections</a></p>\n<p>See <code>glsl-sat-demo.js</code> for usage.</p>\n<p>####Dependencies</p>\n<ul>\n<li>nodejs</li>\n<li>browserify</li>\n<li><a href=\"https://github.com/realazthat/glsl-quad\">glsl-quad</a></li>\n<li><a href=\"https://github.com/mikolalysenko/regl\">regl</a></li>\n<li><a href=\"https://github.com/realazthat/glsl-numerify\">glsl-numerify</a> (for demo)</li>\n<li><a href=\"https://github.com/mikolalysenko/resl\">resl</a> (for demo)</li>\n<li>budo (for quick demo as an alternative to running browserify) </li>\n</ul>\n<p>####Demo</p>\n<p>To run the demo, run:</p>\n<pre><code>    cd ./glsl-sat\n\n    #install npm dependencies\n    npm install\n\n    #browser should open with the demo\n    budo glsl-sat-demo.js --open\n</code></pre><p><strong>Live:</strong></p>\n<table>\n<thead>\n<tr>\n<th>branch</th>\n<th>demo</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>master</td>\n<td><a href=\"https://realazthat.github.io/glsl-sat/master/www/glsl-sat-demo/index.html\">glsl-sat-demo</a></td>\n</tr>\n<tr>\n<td>develop</td>\n<td><a href=\"https://realazthat.github.io/glsl-sat/develop/www/glsl-sat-demo/index.html\">glsl-sat-demo</a></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>Source Upscaled</th>\n<th>Source Red Numerified</th>\n<th>SAT Result Upscaled</th>\n<th>SAT Result Red Numerified</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"http://i.imgur.com/nhR71n4.png\" alt=\"Source Upscaled\"></td>\n<td><img src=\"http://i.imgur.com/0iVMjng.png\" alt=\"Source Red Numerified\"></td>\n<td><img src=\"http://i.imgur.com/4o4aEv9.png\" alt=\"SAT Result Upscaled\"></td>\n<td><img src=\"http://i.imgur.com/f0eBldB.png\" alt=\"SAT Result Red Numerified\"></td>\n</tr>\n</tbody>\n</table>\n<p>####Docs</p>\n<pre><code>const sat = require(&apos;./glsl-sat.js&apos;);\n</code></pre><h5 id=\"sat-computenumpasses-texturesize-samplesize-\"><code>sat.computeNumPasses ({textureSize, sampleSize})</code></h5>\n<ul>\n<li>Computes the number of passes that will be required for a texture of this size, for a single direction.\nActual number of passes will be double what this returns.</li>\n<li><code>textureSize</code> - the size of the texture in pixels. This should be the largest side.</li>\n<li><code>sampleSize</code> - Sample size is stuck at 16 right now, so use 16.</li>\n</ul>\n<h5 id=\"sat-computenumbitsrequired-width-height-channelbitdepth-\"><code>sat.computeNumBitsRequired ({width, height, channelBitDepth})</code></h5>\n<ul>\n<li>Computes the number of bits of precision required to process and hold the resulting SAT texture, in the\nintermediary and result FBOs. Note that this is theoretical; a few bits might be lost with 32 bit floats,\nexperimentation required.</li>\n<li><code>width</code> the input texture width.</li>\n<li><code>height</code> the input texture height.</li>\n<li><code>channelBitDepth</code> the input texture bits per channel.</li>\n</ul>\n<h5 id=\"-sat-computesat-regl-texture-fbos-currentfboindex-0-outfbo-null-components-rgba-type-vec4-clipy-1-\">`sat.computeSat ({regl, texture, fbos, currentFboIndex = 0, outFbo = null, components = &apos;rgba&apos;, type = &apos;vec4&apos;, clipY = 1})</h5>\n<ul>\n<li>Does all the heavy lifting and computes the summed area table.</li>\n<li><code>regl</code> - a regl context.</li>\n<li><code>texture</code> - the regl input texture. should prolly be in opengl form; where the origin uv is the lower left of the texture.</li>\n<li><code>fbos</code> - an array with at least 2 regl FBOs, used for ping-ponging during processing; should prolly have<pre><code>     a type of float (32-bit) for each channel.\n</code></pre></li>\n<li><code>currentFboIndex</code> the regl FBO index in <code>fbos</code> array to begin at for ping-ponging. The function will begin by incrementing this<pre><code>              value and using the next FBO in the array. The function will return a value in the form of\n              `{currentFboIndex}` with the position of the last-used FBO. Defaults to `0`.\n</code></pre></li>\n<li><code>outFbo</code> - destination regl FBO. Can be null, in which case the SAT will be left inside the <code>fbos</code> array<pre><code>       on the last ping-pong; the return value with be of the form `{currentFboIndex}` so that you\n       can retrieve it.\n</code></pre></li>\n<li><code>components</code> - a string indicating which components need to be processed and summed; defaults to <code>&apos;rgba&apos;</code>.</li>\n<li><code>type</code> - a glsl type in string format indicating the type that can hold the compnents that need to be processed; defaults to <code>&apos;vec4&apos;</code>.</li>\n<li><code>clipY</code> - a value that represents the clipspace y multiple; a default value of <code>1</code> indicates opengl-style lower-left-corner-as-origin;<pre><code>       a value of `-1` would mean a upper-left-corner-as-origin.\n</code></pre></li>\n<li>returns a value in the form of <code>{currentFboIndex}</code> with the position of the last-used FBO.</li>\n</ul>\n<p>####Usage</p>\n<p>See <code>glsl-sat-demo.js</code> for a full demo using <a href=\"https://github.com/mikolalysenko/regl\">regl</a>\nand <a href=\"https://github.com/mikolalysenko/resl\">resl</a>.</p>\n<p>An excerpt:</p>\n<pre><code>  computeSat({texture: texture, fbos: fbos, outFbo: outFbo, regl});\n</code></pre>"}