{"readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/realazthat/glsl-zoom\">glsl-zoom</a><div class=\"contrib\"></div></h1>\n<p>####Description</p>\n<p>glsl-zoom is a shader generator for WebGL, to easily display a specific subwindow (zoom) of a larger texture.</p>\n<p>See <code>glsl-zoom-demo.js</code> for usage.</p>\n<p>####Dependencies</p>\n<ul>\n<li>nodejs</li>\n<li>browserify</li>\n<li><a href=\"https://github.com/realazthat/glsl-quad\">glsl-quad</a></li>\n<li><a href=\"https://github.com/mikolalysenko/regl\">regl</a> (for demo)</li>\n<li><a href=\"https://github.com/mikolalysenko/resl\">resl</a> (for demo)</li>\n<li>jquery-browserify (for demo)</li>\n<li>nunjucks (for demo)</li>\n<li>budo (for quick demo as an alternative to running browserify) </li>\n</ul>\n<p>####Demo</p>\n<p>To run the demo, run:</p>\n<pre><code>    cd ./glsl-zoom\n\n    #install npm dependencies\n    npm install\n\n    #browser should open with the demo\n    budo glsl-zoom-demo.js --open\n</code></pre><p>Results:</p>\n<table>\n<thead>\n<tr>\n<th>branch</th>\n<th>demo</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>master</td>\n<td><a href=\"https://realazthat.github.io/glsl-zoom/master/www/glsl-zoom-demo/index.html\">glsl-zoom-demo</a></td>\n</tr>\n<tr>\n<td>develop</td>\n<td><a href=\"https://realazthat.github.io/glsl-zoom/develop/www/glsl-zoom-demo/index.html\">glsl-zoom-demo</a></td>\n</tr>\n</tbody>\n</table>\n<p>####Docs</p>\n<pre><code>const zoom = require(&apos;./glsl-zoom.js&apos;);\n</code></pre><p>The general idea is:</p>\n<ol>\n<li>the library acts almost like <a href=\"https://github.com/realazthat/glsl-quad\">glsl-quad</a>.</li>\n<li>it provides vertices, indices, uvs, vertex and fragment shaders.</li>\n<li>it requires the same uniforms as <code>glsl-quad</code>.</li>\n<li>it requires two additional uniforms that represent the view-rectangle within the texture.</li>\n<li>a smaller view-rectangle means a closer zoom.</li>\n<li>the view-rectangle is specified via a &quot;lower&quot; and &quot;upper&quot; set of coordinates.</li>\n<li>the view-rectangle is in the same units as the uvs.</li>\n</ol>\n<h5 id=\"zoom-verts\"><code>zoom.verts</code></h5>\n<ul>\n<li>A list of vertices that can be used for webgl positions, that make up a quad (two triangles).</li>\n</ul>\n<h5 id=\"zoom-indices\"><code>zoom.indices</code></h5>\n<ul>\n<li>A list of indices that can be used for webgl triangles, that make up a quad (two triangles).</li>\n</ul>\n<h5 id=\"zoom-uvs\"><code>zoom.uvs</code></h5>\n<ul>\n<li>A list of uv attributes for the vertices.</li>\n</ul>\n<h5 id=\"zoom-shader-vert-\"><code>zoom.shader.vert()</code></h5>\n<ul>\n<li>Returns the webgl 1.0 vertex shader to use.</li>\n<li>The vertex shader expects:<ul>\n<li>A uniform float named <code>u_clip_y</code>, representing whether to flip the y-axis; values of 1 or -1.</li>\n<li>An attribute list of vec2 positions of the vertices named <code>a_position</code>.</li>\n<li>An attribute list of vec2 uvs of the vertices named <code>a_uv</code>.</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"zoom-shader-frag-borderclamp-false-bordercolor-vec4-0-0-0-1-\"><code>zoom.shader.frag({borderClamp = false, borderColor = &apos;vec4(0,0,0,1)})</code></h5>\n<ul>\n<li>A function that returns the webgl 1.0 fragment shader to use.</li>\n<li><code>borderClamp</code> - A boolean indicating if the shader should use a border color when\nshowing things off the edge of the texture; default is false, and the result is whatever\nWebGL clamping is chosen.</li>\n<li><code>borderColor</code> - A string containing a glsl vec4 value that will be used the for the<pre><code>            over-the-border-color if `borderClamp` is set to true. can optionally\n            use the keyword string `uniform`, which will then make the fragment\n            shader expect a uniform `vec4` with the name `u_border`.\n</code></pre></li>\n<li>The fragment shader uniforms:<ul>\n<li>A uniform shader (sampler2D) named <code>u_tex</code>.</li>\n<li>A uniform <code>vec2</code> named <code>u_zoom_uv_lower</code>, having values in the range [0,1],\nand representing the &quot;lower&quot; corner of a rectangle in uv-space of the texture.\nNote that opengl convention is uv-origin at the lower-left.</li>\n<li>A uniform <code>vec2</code> named <code>u_zoom_uv_upper</code>, having values in the range [0,1],\nand representing the &quot;upper&quot; corner of a rectangle in uv-space of the texture.\nNote that opengl convention is uv-origin at the lower-left.</li>\n<li>Optionally, if <code>borderClamp</code> is set as true, a uniform <code>vec4</code> named <code>u_border</code>,\nhaving a color value (each component in the range <code>[0, 1]</code>). This color will be\nused for pixels that are not within the texture (i.e instead of whatever clamp\nthe texture is set to).</li>\n</ul>\n</li>\n</ul>\n<p>####Advanced Docs</p>\n<p>Controlling the view window is simple, but powerful, but can be a bit of work.</p>\n<p><code>glsl-zoom</code> provides some helper functions to do this. The following is the API documentation\nof these functions.</p>\n<h5 id=\"zoomregion\"><code>zoomRegion</code></h5>\n<p>A common argument in the API, which represents a &quot;circular&quot; zoom region, with a center, and a radius.\n<strong>Note that although it has a &quot;radius&quot;, the library currently supports only\n&quot;<a href=\"https://en.wikipedia.org/wiki/Taxicab_geometry\">manhattan distance</a>&quot;, which\neffectively makes it a rectangle</strong>.</p>\n<p>The form is documented here, instead of in each method:</p>\n<pre><code>// pointing at the center, with a radius covering the entire texture.\nlet zoomRegion = {\n  center: {x: .5, y: .5},\n  radius: {x: .5, y: .5}\n};\n</code></pre><h5 id=\"zoom-region-translate-zoomregion-delta-bounds-null-boundtype-overlap-\"><code>zoom.region.translate ({zoomRegion, delta, bounds = null, boundType = &apos;overlap&apos;})</code></h5>\n<p>This function translates a <code>zoomRegion</code> in-place, by <code>delta</code>.</p>\n<ul>\n<li><code>zoomRegion</code> - The region that needs to be translated.</li>\n<li><code>delta</code> - The delta to translate the <code>zoomRegion</code> by; of the form <code>{x: 0.1, y: -0.2}</code>.</li>\n<li><code>bounds</code> - An optional parameter that will bound the translation, the type of bounding<pre><code>      is specified by the `boundType` argument. `bounds` is of the form\n      `bounds = {lower: {x: 0, y: 0}, upper: {x: 1, y: 1}}`. Defaults to `null`,\n      which means it will not be bounded and the function will translate freely.\n</code></pre></li>\n<li><code>boundType</code> - A string value, one of <code>overlap</code> or <code>clamp</code>. Goes together with the <code>bounds</code><pre><code>      parameter. Defaults to `overlap`. **NOTE: this argument is named **`boundType`**,\n      NOT `boundsType`.\n      * `clamp` - the `zoomRegion` will not be allowed to translate\n          outside of the `bounds` at all.\n      * `overlap` - the `zoomRegion` will not be allowed to translate to a location where\n          it can no longer see the `bounds` region.\n</code></pre></li>\n</ul>\n<h5 id=\"zoom-region-scale-zoomregion-ratio-bounds-null-boundtype-overlap-minimumradius-x-1-0-1-30-y-1-0-1-30-maximumradius-null-\"><code>zoom.region.scale (zoomRegion, ratio, bounds = null, boundType = &apos;overlap&apos;, minimumRadius = {x: 1.0 / (1 &lt;&lt; 30), y: 1.0 / (1 &lt;&lt; 30)}, maximumRadius = null)</code></h5>\n<p>Scales the <code>zoomRegion</code> by modifying the radius. Operates in-place.\nSimilar to <code>zoom.region.translate()</code>, see that method for more detailed\ndocs on some of the params.</p>\n<ul>\n<li><code>zoomRegion</code> - The region that needs to be translated.</li>\n<li><code>ratio</code> - The radius will be multiplied by this value.</li>\n<li><code>bounds</code> - The radius will not grow outside of the bounds, which has a different logical meaning<pre><code>        depending on the value of `boundType`. See `zoom.region.translate()`.\n</code></pre></li>\n<li><code>boundType</code> - Modifies the meaning of the <code>bounds</code> argument. See <code>zoom.region.translate()</code>.</li>\n<li><code>minimumRadius</code> - Before and after scaling, the radius will be clamped between <code>minimumRadius</code><pre><code>              and `maximumRadius`, if they are not `null`. This can be important for avoiding\n              `NaNs`. Defaults to a very small number (`1.0 / (1 &lt;&lt; 30)`).\n</code></pre></li>\n</ul>\n<h5 id=\"zoom-region-clamp-zoomregion-bounds-null-boundtype-overlap-minimumradius-x-1-0-1-30-y-1-0-1-30-maximumradius-null-\"><code>zoom.region.clamp ({ zoomRegion, bounds = null, boundType = &apos;overlap&apos;, minimumRadius = {x: 1.0 / (1 &lt;&lt; 30), y: 1.0 / (1 &lt;&lt; 30)}, maximumRadius = null})</code></h5>\n<p>Clamps the region, by <code>bounds</code> or by radius. See <code>zoom.region.translate()</code>.</p>\n<h5 id=\"zoom-region-clone-zoomregion-\"><code>zoom.region.clone ({zoomRegion})</code></h5>\n<p>Returns a deep copy of a <code>zoomRegion</code>.</p>\n<h5 id=\"zoom-test-bounds-overlaps-zoomregion-bounds-\"><code>zoom.test.bounds.overlaps ({zoomRegion, bounds})</code></h5>\n<p>Checks if a <code>zoomRegion</code> overlaps a <code>bounds</code>.  See <code>zoom.region.translate()</code>.</p>\n<h5 id=\"zoom-test-bounds-contains-zoomregion-bounds-\"><code>zoom.test.bounds.contains ({zoomRegion, bounds})</code></h5>\n<p>Checks if a <code>zoomRegion</code> is completely contained by <code>bounds</code>.  See <code>zoom.region.translate()</code>.</p>\n<h5 id=\"zoom-util-delta-kbd-downkeys-\"><code>zoom.util.delta.kbd ({downKeys})</code></h5>\n<p>A helper function that computes a <code>delta</code> from the current set of keyboard keys that are pressed.</p>\n<ul>\n<li><p><code>downKeys - A dictionary of JavaScript &quot;key codes&quot; as keys, and</code>true/false` values to indicate</p>\n<pre><code>        which keys are currently pressed.\n</code></pre></li>\n<li><p>Returns a dictionary of the form <code>{x: +1, y: 0}</code> which indicates what the combination of arrow\nkeys, numpad keys, <code>WASD</code> keys make up in intended direction.</p>\n</li>\n</ul>\n<h5 id=\"zoom-uv-lower-zoomregion-\"><code>zoom.uv.lower ({zoomRegion})</code></h5>\n<p>Returns a list of the two lower coordinates.</p>\n<p>So a region like <code>zoomRegion = {center: {x: 0.5, y: 0.5}, radius: {x: 0.1, y: 0.1}}</code> would result\nin a list such as <code>[0.4, 0.4]</code>.</p>\n<h5 id=\"zoom-uv-lower-zoomregion-\"><code>zoom.uv.lower ({zoomRegion})</code></h5>\n<p>Returns a list of the two upper coordinates.</p>\n<p>So a region like <code>zoomRegion = {center: {x: 0.5, y: 0.5}, radius: {x: 0.1, y: 0.1}}</code> would result\nin a list such as <code>[0.6, 0.6]</code>.</p>\n<p>####Usage</p>\n<p>See <code>glsl-zoom-demo.js</code> for a full demo using <a href=\"https://github.com/mikolalysenko/regl\">regl</a>\nand <a href=\"https://github.com/mikolalysenko/resl\">resl</a>.</p>\n<p>An excerpt:</p>\n<pre><code>    const drawTexture = regl({\n      vert: zoom.shader.vert(),\n      frag: zoom.shader.frag({borderClamp: true, borderColor: &apos;uniform&apos;}),\n      attributes: {\n        a_position: zoom.verts,\n        a_uv: zoom.uvs\n      },\n      elements: zoom.indices,\n      uniforms: {\n        u_tex: regl.prop(&apos;texture&apos;),\n        u_clip_y: 1,\n        u_zoom_uv_lower: regl.prop(&apos;lower&apos;),\n        u_zoom_uv_upper: regl.prop(&apos;upper&apos;),\n        u_border: [0, 0, 0, 1]\n      }\n    });\n\n    // will zoom into a region of the texture from `(0.2, 0.2) =&gt; (0.7, 0.7)`, a 2X zoom in.\n    // change these values to control the view-window.\n    drawTexture({texture, lower: [.2, .2], upper: [.7, .7]});\n</code></pre>"}