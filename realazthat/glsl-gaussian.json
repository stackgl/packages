{"readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/realazthat/glsl-gaussian\">glsl-gaussian</a><div class=\"contrib\"></div></h1>\n<p>####Description</p>\n<p>glsl-gaussian is a shader generator for WebGL, to generate a gaussian blur of an input texture.</p>\n<p>See <code>glsl-gaussian-live-demo.js</code>, <code>glsl-gaussian-demo.js</code> for usage.</p>\n<p>####Dependencies</p>\n<ul>\n<li>nodejs</li>\n<li>browserify</li>\n<li><a href=\"https://github.com/realazthat/glsl-quad\">glsl-quad</a></li>\n<li><a href=\"https://github.com/realazthat/glsl-sat\">glsl-sat</a></li>\n<li><a href=\"https://github.com/mikolalysenko/regl\">regl</a></li>\n<li><a href=\"https://github.com/realazthat/glsl-numerify\">glsl-numerify</a> (for demo)</li>\n<li><a href=\"https://github.com/mikolalysenko/resl\">resl</a> (for demo)</li>\n<li>budo (for quick demo as an alternative to running browserify) </li>\n</ul>\n<p>####Demo</p>\n<p>To run the demo, run:</p>\n<pre><code>    cd ./glsl-gaussian\n\n    #install npm dependencies\n    npm install\n\n    #browser should open with the demo\n    budo glsl-gaussian-demo.js --open\n\n    #browser should open with the demo\n    budo glsl-gaussian-live-demo.js --open\n</code></pre><p><strong>Live:</strong></p>\n<table>\n<thead>\n<tr>\n<th>branch</th>\n<th>demo</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>master</td>\n<td><a href=\"https://realazthat.github.io/glsl-gaussian/master/www/glsl-gaussian-demo/index.html\">glsl-gaussian-demo</a></td>\n</tr>\n<tr>\n<td><a href=\"https://realazthat.github.io/glsl-gaussian/master/www/glsl-gaussian-live-demo/index.html\">glsl-gaussian-live-demo</a></td>\n<td></td>\n</tr>\n<tr>\n<td>develop</td>\n<td><a href=\"https://realazthat.github.io/glsl-gaussian/develop/www/glsl-gaussian-demo/index.html\">glsl-gaussian-demo</a></td>\n</tr>\n<tr>\n<td><a href=\"https://realazthat.github.io/glsl-gaussian/develop/www/glsl-gaussian-live-demo/index.html\">glsl-gaussian-live-demo</a></td>\n</tr>\n</tbody>\n</table>\n<p><strong>Results:</strong></p>\n<p>(Image credit: <a href=\"http://www.nasa.gov/content/storm-cell-over-the-southern-appalachian-mountains\">Storm Cell Over the Southern Appalachian Mountains</a>,\n<em>NASA / Stu Broce</em>, public domain by virtue of being created by NASA)</p>\n<table>\n<thead>\n<tr>\n<th>Source Image</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://raw.githubusercontent.com/realazthat/glsl-gaussian/master/./assets/Storm Cell Over the Southern Appalachian Mountains-dsc_2303_0-256x256.png\"></p>\n<table>\n<thead>\n<tr>\n<th>Gaussian Blur with radius 1</th>\n<th>Gaussian Blur with radius 2</th>\n<th>Gaussian Blur with radius 4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src=\"https://raw.githubusercontent.com/realazthat/glsl-gaussian/master/./assets/result-256x256x-r1.png\"></td>\n<td><img src=\"https://raw.githubusercontent.com/realazthat/glsl-gaussian/master/./assets/result-256x256x-r2.png\"></td>\n<td><img src=\"https://raw.githubusercontent.com/realazthat/glsl-gaussian/master/./assets/result-256x256x-r4.png\"></td>\n</tr>\n</tbody>\n</table>\n<p>####Docs</p>\n<pre><code>const gaussian = require(&apos;./glsl-gaussian.js&apos;);\n</code></pre><h5 id=\"gaussian-blur-gaussian-compute-regl-texture-radius-fbos-currentfboindex-0-boxpasses-3-outfbo-null-components-rgba-type-vec4-clipy-1-\"><code>gaussian.blur.gaussian.compute ({regl, texture, radius, fbos, currentFboIndex = 0, boxPasses = 3, outFbo = null, components = &apos;rgba&apos;, type = &apos;vec4&apos;, clipY = 1})</code></h5>\n<ul>\n<li>Computes the guassian blur of the given texture.</li>\n<li><code>regl</code> - a regl context.</li>\n<li><code>radius</code> - The radius of the gaussian blur; that is to say, the kernel window around the pixel will be of size <code>(2*radius+1)X(2*radius+1)</code>.</li>\n<li><code>fbos</code> - an array with at least 2 regl FBOs, used for ping-ponging during processing; should prolly have<pre><code>     a type of float (32-bit) for each channel.\n</code></pre></li>\n<li><code>currentFboIndex</code> the regl FBO index in <code>fbos</code> array to begin at for ping-ponging. The function will begin by incrementing this<pre><code>              value and using the next FBO in the array. The function will return a value in the form of\n              `{currentFboIndex}` with the position of the last-used FBO. Defaults to `0`.\n</code></pre></li>\n<li><code>outFbo</code> - destination regl FBO. Can be null, in which case the result will be left inside the <code>fbos</code> array<pre><code>       on the last ping-pong; the return value with be of the form `{currentFboIndex}` so that you\n       can retrieve it.\n</code></pre></li>\n<li><code>components</code> - a string indicating which components need to be processed and blurred; defaults to <code>&apos;rgba&apos;</code>.</li>\n<li><code>type</code> - a glsl type in string format indicating the type that can hold the components that need to be processed; defaults to <code>&apos;vec4&apos;</code>.</li>\n<li><code>clipY</code> - a value that represents the clipspace y multiple; a default value of <code>1</code> indicates opengl-style lower-left-corner-as-origin;<pre><code>       a value of `-1` would mean a upper-left-corner-as-origin.\n</code></pre></li>\n</ul>\n<h5 id=\"gaussian-blur-box-shader-vert-texturewidth-textureheight-radius-components-rgba-type-vec4-\"><code>gaussian.blur.box.shader.vert ({textureWidth, textureHeight, radius, components = &apos;rgba&apos;, type = &apos;vec4&apos;})</code></h5>\n<ul>\n<li>Generate a vertex shader that computes the box blur from a Summed Area Table texture.\n  Returns the vertex shader as a string.</li>\n<li><code>textureWidth</code> - The width of the inputtexture.</li>\n<li><code>textureHeight</code> - The height of the input texture.</li>\n<li><code>radius</code> - The radius of the box blur; that is to say, the box around the pixel will be of size <code>(2*radius+1)X(2*radius+1)</code>. </li>\n<li><code>components</code> - a string indicating which components need to be processed and blurred; defaults to <code>&apos;rgba&apos;</code>.</li>\n<li><code>type</code> - a glsl type in string format indicating the type that can hold the components that need to be processed; defaults to <code>&apos;vec4&apos;</code>.</li>\n</ul>\n<h5 id=\"gaussian-blur-box-shader-frag-texturewidth-textureheight-radius-components-rgba-type-vec4-\"><code>gaussian.blur.box.shader.frag ({textureWidth, textureHeight, radius, components = &apos;rgba&apos;, type = &apos;vec4&apos;})</code></h5>\n<ul>\n<li>Generate a fragment shader that computes the box blur from a Summed Area Table texture.\n  Returns the fragment shader as a string.</li>\n<li>See <code>gaussian.box.shader.vert()</code> for params.</li>\n</ul>\n<h5 id=\"gaussian-blur-box-compute-regl-src-radius-outfbo-null-components-rgba-type-vec4-clipy-1-\"><code>gaussian.blur.box.compute ({regl, src, radius, outFbo = null, components = &apos;rgba&apos;, type = &apos;vec4&apos;, clipY = 1})</code></h5>\n<ul>\n<li>Given an input texture, will compute the box blur.</li>\n<li><code>regl</code> - a regl context.</li>\n<li><code>src</code> - A dictionary of the form <code>{satTexture}</code> OR <code>{texture, fbos, currentFboIndex}</code>.<ul>\n<li>In the first form, the Summed Area Table\nis provided by you, the user. No FBOs are needed, just be sure to specify the <code>outFbo</code> argument.</li>\n<li>In the second form, you provide the input texture yourself (via the <code>texture</code> argument), and FBOs\nfor pingponging during computation of SAT. The FBOs should be an array of at least 2. The FBOs\nshould prolly be of a high precision type (such as float 32 bit). <code>currentFboIndex</code> will be\nreturned in the form <code>{currentFboIndex}</code> representing the last-used FBO. If <code>outFbo</code> is not\nspecified, then this FBO slot will hold the result of the blur.</li>\n</ul>\n</li>\n<li><code>radius</code> - The radius of the box blur; that is to say, the box around the pixel will be of size (2*radius+1). </li>\n<li><code>outFbo</code> - Destination regl FBO. Can be null, in which case <code>src.fbos</code> is expected to exist; the result of<pre><code>       of the computation will be left inside the `src.fbos` array on the last ping-pong; the return\n       value with be of the form `{currentFboIndex}` so that you can retrieve it.\n</code></pre></li>\n<li><code>components</code> - a string indicating which components need to be processed and blurred; defaults to <code>&apos;rgba&apos;</code>.</li>\n<li><code>type</code> - a glsl type in string format indicating the type that can hold the components that need to be processed; defaults to <code>&apos;vec4&apos;</code>.</li>\n<li><code>clipY</code> - a value that represents the clipspace y multiple; a default value of <code>1</code> indicates opengl-style lower-left-corner-as-origin;<pre><code>       a value of `-1` would mean a upper-left-corner-as-origin.\n</code></pre></li>\n</ul>\n<p>####Usage</p>\n<p>See <code>glsl-gaussian-demo.js</code> for a full demo using <a href=\"https://github.com/mikolalysenko/regl\">regl</a>\nand <a href=\"https://github.com/mikolalysenko/resl\">resl</a>.</p>\n<p>An excerpt:</p>\n<pre><code>  gaussian.blur.gaussian.compute({regl, texture, radius, fbos, outFbo, components: &apos;rgb&apos;, type: &apos;vec3&apos;});\n</code></pre>"}