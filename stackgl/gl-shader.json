{"readme":"<h1 class=\"title\"><a target=\"_blank\" href=\"https://github.com/stackgl/gl-shader\">gl-shader</a><div class=\"contrib\"></div></h1>\n<p>A wrapper for WebGL shaders.  Part of <a href=\"http://stack.gl\">stack.gl</a></p>\n<iframe scrolling=\"no\" seamless=\"seamless\" src=\"http://stack.gl/gl-shader/\"></iframe><h2 id=\"example\">Example</h2>\n<p>Try it out now in your browser:  <a href=\"http://stackgl.github.io/gl-shader/\">http://stackgl.github.io/gl-shader/</a></p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>var&#xA0;shell&#xA0;=&#xA0;require(&apos;gl-now&apos;)()</span></span></div><div class=\"line\"><span class=\"source js\"><span>var&#xA0;createShader&#xA0;=&#xA0;require(&apos;gl-shader&apos;)</span></span></div><div class=\"line\"><span class=\"source js\"><span>var&#xA0;shader,&#xA0;buffer</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>shell.on(&apos;gl-init&apos;,&#xA0;function()&#xA0;{</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;var&#xA0;gl&#xA0;=&#xA0;shell.gl</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;//Create&#xA0;shader</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;shader&#xA0;=&#xA0;createShader(gl,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&apos;attribute&#xA0;vec3&#xA0;position;\\</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;varying&#xA0;vec2&#xA0;uv;\\</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;void&#xA0;main()&#xA0;{\\</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;gl_Position&#xA0;=&#xA0;vec4(position,&#xA0;1.0);\\</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;uv&#xA0;=&#xA0;position.xy;\\</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;}&apos;,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&apos;precision&#xA0;highp&#xA0;float;\\</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;uniform&#xA0;float&#xA0;t;\\</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;varying&#xA0;vec2&#xA0;uv;\\</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;void&#xA0;main()&#xA0;{\\</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;gl_FragColor&#xA0;=&#xA0;vec4(0.5*(uv+1.0),&#xA0;0.5*(cos(t)+1.0),&#xA0;1.0);\\</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;}&apos;)</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;//Create&#xA0;vertex&#xA0;buffer</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;buffer&#xA0;=&#xA0;gl.createBuffer()</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;gl.bindBuffer(gl.ARRAY_BUFFER,&#xA0;buffer)</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;gl.bufferData(gl.ARRAY_BUFFER,&#xA0;new&#xA0;Float32Array([</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;-1,&#xA0;0,&#xA0;0,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;0,&#xA0;-1,&#xA0;0,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;1,&#xA0;1,&#xA0;0</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;]),&#xA0;gl.STATIC_DRAW)</span></span></div><div class=\"line\"><span class=\"source js\"><span>})</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>shell.on(&apos;gl-render&apos;,&#xA0;function(t)&#xA0;{</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;var&#xA0;gl&#xA0;=&#xA0;shell.gl</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;//Bind&#xA0;shader</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;shader.bind()</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;//Set&#xA0;attributes</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;gl.bindBuffer(gl.ARRAY_BUFFER,&#xA0;buffer)</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;shader.attributes.position.pointer()</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;//Set&#xA0;uniforms</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;shader.uniforms.t&#xA0;+=&#xA0;0.01</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;//Draw</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;gl.drawArrays(gl.TRIANGLES,&#xA0;0,&#xA0;3)</span></span></div><div class=\"line\"><span class=\"source js\"><span>})</span></span></div>\n</code></pre>\n<p>Here is the result:</p>\n<p><img src=\"https://raw.github.com/stackgl/gl-shader/master/screenshot.png\"></p>\n<h2 id=\"install\">Install</h2>\n<pre><code>npm install gl-shader\n</code></pre><h2 id=\"api\">API</h2>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>var&#xA0;createShader&#xA0;=&#xA0;require(&apos;gl-shader&apos;)</span></span></div>\n</code></pre>\n<h3 id=\"constructor\">Constructor</h3>\n<p>There are two main usages for the constructor.  First,</p>\n<h4 id=\"var-shader-createshader-gl-vertexsource-fragmentsource-uniforms-attributes-\"><code>var shader = createShader(gl, vertexSource, fragmentSource[, uniforms, attributes])</code></h4>\n<p>Constructs a wrapped shader object with shims for all of the uniforms and attributes in the program.</p>\n<ul>\n<li><code>gl</code> is the webgl context in which the program will be created</li>\n<li><code>vertexSource</code> is the source code for the vertex shader</li>\n<li><code>fragmentSource</code> is the source code for the fragment shader</li>\n<li><code>uniforms</code> is an (optional) list of all uniforms exported by the shader program</li>\n<li><code>attributes</code> is an (optional) list of all attributes exported by the shader program</li>\n</ul>\n<p>The optional <code>uniforms</code> and <code>attributes</code> arrays have the following format. This will be extracted at run-time from the shader, so you can typically omit the <code>uniforms</code> and <code>attributes</code> arguments.</p>\n<pre><code class=\"lang-js\"><div class=\"line\"><span class=\"source js\"><span>{</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;uniforms:&#xA0;[</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;{&#xA0;type:&#xA0;&apos;mat4&apos;,&#xA0;name:&#xA0;&apos;projection&apos;&#xA0;},</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;{&#xA0;type:&#xA0;&apos;sampler2D&apos;,&#xA0;name:&#xA0;&apos;texture0&apos;&#xA0;}</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;],</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;attributes:&#xA0;[</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;{&#xA0;type:&#xA0;&apos;vec3&apos;,&#xA0;name:&#xA0;&apos;position&apos;&#xA0;}</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;]</span></span></div><div class=\"line\"><span class=\"source js\"><span>}</span></span></div>\n</code></pre>\n<p>You can specify a default <code>location</code> number for each attribute, otherwise WebGL will bind it automatically. </p>\n<p><strong>Returns</strong> A compiled shader object.</p>\n<h4 id=\"var-shader-createshader-gl-opt-\"><code>var shader = createShader(gl, opt)</code></h4>\n<p>The same as above, but takes an object instead of a parameter list.</p>\n<ul>\n<li><code>gl</code> is a WebGL context</li>\n<li><code>opt.vertex</code> a vertex shader source</li>\n<li><code>opt.fragment</code> a fragment shader source</li>\n<li><code>opt.uniforms</code> (optional) a list of uniforms</li>\n<li><code>opt.attributes</code> (optional) a list of attributes</li>\n</ul>\n<p><strong>Returns</strong> A wrapped shader object</p>\n<h3 id=\"methods\">Methods</h3>\n<h4 id=\"shader-bind-\"><code>shader.bind()</code></h4>\n<p>Binds the shader for rendering</p>\n<h4 id=\"shader-update-vertsource-fragsource-uniforms-attributes-\"><code>shader.update(vertSource,fragSource[,uniforms,attributes])</code></h4>\n<p>Rebuilds the shader object with new vertex and fragment shaders (same behavior as constructor)</p>\n<h4 id=\"shader-update-opt-\"><code>shader.update(opt)</code></h4>\n<p>Rebuilds the shader object with new vertex and fragment shaders (same behavior as constructor)</p>\n<h4 id=\"shader-dispose-\"><code>shader.dispose()</code></h4>\n<p>Deletes the shader program and associated resources.</p>\n<h3 id=\"properties\">Properties</h3>\n<h4 id=\"gl\"><code>gl</code></h4>\n<p>The WebGL context associated to the shader</p>\n<h4 id=\"program\"><code>program</code></h4>\n<p>A reference to the underlying program object in the WebGL context</p>\n<h4 id=\"vertshader\"><code>vertShader</code></h4>\n<p>A reference to the underlying vertex shader object</p>\n<h4 id=\"fragshader\"><code>fragShader</code></h4>\n<p>A reference to the underlying fragment shader object</p>\n<h3 id=\"uniforms\">Uniforms</h3>\n<p>The uniforms for the shader program are packaged up as properties in the <code>shader.uniforms</code> object.  The shader must be bound before the uniforms are assigned. For example, to update a scalar uniform you can just assign to it:</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>shader.bind()</span></span></div><div class=\"line\"><span class=\"source js\"><span>shader.uniforms.scalar&#xA0;=&#xA0;1.0</span></span></div>\n</code></pre>\n<p>While you can update vector uniforms by writing an array to them:</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>shader.uniforms.vector&#xA0;=&#xA0;[1,0,1,0]</span></span></div>\n</code></pre>\n<p>Matrix uniforms must have their arrays flattened first:</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>shader.uniforms.matrix&#xA0;=&#xA0;[&#xA0;1,&#xA0;0,&#xA0;1,&#xA0;0,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;0,&#xA0;1,&#xA0;0,&#xA0;0,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;0,&#xA0;0,&#xA0;1,&#xA0;1,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;0,&#xA0;0,&#xA0;0,&#xA0;1&#xA0;]</span></span></div>\n</code></pre>\n<p>You can read the value of uniform too if the underlying shader is currently bound.  For example,</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>shader.bind()</span></span></div><div class=\"line\"><span class=\"source js\"><span>console.log(shader.uniforms.scalar)</span></span></div><div class=\"line\"><span class=\"source js\"><span>console.log(shader.uniforms.vector)</span></span></div><div class=\"line\"><span class=\"source js\"><span>console.log(shader.uniforms.matrix)</span></span></div>\n</code></pre>\n<p>Struct uniforms can also be accessed using the normal dot property syntax:</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>shader.uniforms.light[0].color&#xA0;=&#xA0;[1,&#xA0;0,&#xA0;0,&#xA0;1]</span></span></div>\n</code></pre>\n<p>It is also possible to initialize uniforms in bulk by assigning an object:</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>shader.uniforms&#xA0;=&#xA0;{</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;model:&#xA0;&#xA0;[1,&#xA0;0,&#xA0;0,&#xA0;0,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;0,&#xA0;1,&#xA0;0,&#xA0;0,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;0,&#xA0;0,&#xA0;1,&#xA0;0,</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;0,&#xA0;0,&#xA0;0,&#xA0;1],</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;&#xA0;color:&#xA0;&#xA0;[1,&#xA0;0,&#xA0;1,&#xA0;1]</span></span></div><div class=\"line\"><span class=\"source js\"><span>}</span></span></div>\n</code></pre>\n<p>The contents of uniform values are lost when a shader is unbound.</p>\n<h3 id=\"attributes\">Attributes</h3>\n<p>The basic idea behind the attribute interface is similar to that for uniforms, however because attributes can be either a constant value or get values from a vertex array they have a slightly more complicated interface.  All of the attributes are stored in the <code>shader.attributes</code> property.</p>\n<h4 id=\"attrib-constant\"><code>attrib = constant</code></h4>\n<p>For non-array attributes you can set the constant value to be broadcast across all vertices.  For example, to set the vertex color of a shader to a constant you could do:</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>shader.attributes.color&#xA0;=&#xA0;[1,&#xA0;0,&#xA0;0,&#xA0;1]</span></span></div>\n</code></pre>\n<p>This internally uses <a href=\"http://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttrib.xml\"><code>gl.vertexAttribnf</code></a>. Setting the attribute will also call <code>gl.disableVertexAttribArray</code> on the attribute&apos;s location.</p>\n<h4 id=\"attrib-location\"><code>attrib.location</code></h4>\n<p>This property accesses the location of the attribute.  You can assign/read from it to modify the location of the attribute.  For example, you can update the location by doing:</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>attrib.location&#xA0;=&#xA0;0</span></span></div>\n</code></pre>\n<p>Or you can read the currently bound location back by just accessing it:</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>console.log(attrib.location)</span></span></div>\n</code></pre>\n<p><strong>WARNING</strong> Changing the attribute location requires recompiling the program. This recompilation is deferred until the next call to <code>.bind()</code></p>\n<h4 id=\"attrib-pointer-type-normalized-stride-offset-\"><code>attrib.pointer([type, normalized, stride, offset])</code></h4>\n<p>A shortcut for <code>gl.vertexAttribPointer</code>/<code>gl.enableVertexAttribArray</code>.  See the <a href=\"http://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttribPointer.xml\">OpenGL man page for details on how this works</a>.  The main difference here is that the WebGL context, size and index are known and so these parameters are bound.</p>\n<ul>\n<li><code>type</code> is the type of the pointer (default <code>gl.FLOAT</code>)</li>\n<li><code>normalized</code> specifies whether fixed-point data values should be normalized (<code>true</code>) or converted directly as fixed-point values (<code>false</code>) when they are accessed.  (Default <code>false</code>)</li>\n<li><code>stride</code> the byte offset between consecutive generic vertex attributes.  (Default: <code>0</code>)</li>\n<li><code>offset</code> offset of the first element of the array in bytes. (Default <code>0</code>)</li>\n</ul>\n<h4 id=\"matrix-attributes\">Matrix attributes</h4>\n<p>Matrix attributes are also supported, however there are a few subtle difference.  Due to WebGL limitations, d-dimensional matrix attributes require d separate attribute locations.  If <code>matrix</code> is a matrix attribute, then the rows of the matrix can be accessed independently using:</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>//First&#xA0;row&#xA0;of&#xA0;matrix</span></span></div><div class=\"line\"><span class=\"source js\"><span>shader.attributes.matrix[0]</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>//Second&#xA0;row</span></span></div><div class=\"line\"><span class=\"source js\"><span>shader.attributes.matrix[1]</span></span></div><div class=\"line\"><span class=\"source js\"><span>&#xA0;</span></span></div><div class=\"line\"><span class=\"source js\"><span>//&#xA0;...&#xA0;etc.</span></span></div>\n</code></pre>\n<p>The interface for these attributes is identical to the above interfaces for vector attributes (support constant setters, <code>.pointer()</code>, and <code>.location</code>).</p>\n<p>There is also a bulk interface which simplifies working with the matrix as a whole unit.  For example, it is possible to update the location of each row of the matrix simultaneously by assigning it a vector value:</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>shader.attributes.matrix.location&#xA0;=&#xA0;[1,&#xA0;2,&#xA0;3,&#xA0;4]</span></span></div>\n</code></pre>\n<p>Similarly, if the matrix attribute is stored as a contiguous range in memory, the pointer for each row can be set using <code>.pointer()</code>.  For example, if <code>matrix</code> is a 4x4 matrix attribute then,</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>shader.attributes.matrix.pointer(gl.FLOAT,&#xA0;false,&#xA0;16,&#xA0;0)</span></span></div>\n</code></pre>\n<p>is equivalent to,</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>shader.attributes.matrix[0].pointer(gl.FLOAT,&#xA0;false,&#xA0;16,&#xA0;0)</span></span></div><div class=\"line\"><span class=\"source js\"><span>shader.attributes.matrix[0].pointer(gl.FLOAT,&#xA0;false,&#xA0;16,&#xA0;4)</span></span></div><div class=\"line\"><span class=\"source js\"><span>shader.attributes.matrix[0].pointer(gl.FLOAT,&#xA0;false,&#xA0;16,&#xA0;8)</span></span></div><div class=\"line\"><span class=\"source js\"><span>shader.attributes.matrix[0].pointer(gl.FLOAT,&#xA0;false,&#xA0;16,&#xA0;12)</span></span></div>\n</code></pre>\n<h3 id=\"reflection\">Reflection</h3>\n<p>Finally, the library supports some reflection capabilities.  The set of all uniforms and data types are stored in the &quot;type&quot; property of the shader object,</p>\n<pre><code class=\"lang-javascript\"><div class=\"line\"><span class=\"source js\"><span>console.log(shader.types)</span></span></div>\n</code></pre>\n<p>This reflects the uniform and attribute parameters that were passed to the shader constructor.</p>\n<h2 id=\"acknowledgements\">Acknowledgements</h2>\n<p>(c) 2013-2015 Mikola Lysenko.  MIT License</p>\n"}